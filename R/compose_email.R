#' turns post into email
#'
#' Given a blog post location and which post to fetch (either **latest** or a post title),
#' fetches it and starts setting up the email.
#'
#' @param blog_dir where the blog is (see details)
#' @param post whether to fetch the **latest** post or matching a title
#'
#' @details While it is expected that **most** of the time that `blog_dir` will point
#'   to a local copy of a blog, and that the RSS file is at `_site/index.xml`,
#'   it doesn't have to. `blog_dir` can also be a fully qualified path the RSS file
#'   itself, or even the URL of an RSS file on the web, if you are using some other
#'   blogging platform and dont want to copy the RSS file to your local filesystem.
#'
#' @examples
#' \dontrun{
#' ## Using a local quarto blog,
#' ## where index.xml is under _site/index.xml
#' b2n_post_to_email("path/to/local/blog")
#'
#' ## using a local index.xml that is not in a quarto blog, or a non-standard location
#' b2n_post_to_email("path/to/local/blog/_out/index.xml")
#'
#' ## using a url
#' b2n_post_to_email("https://myblog.com/index.xml")
#' }
#'
#' @export
#' @return list
b2n_post_to_email = function(blog_dir, post = "latest")
{
  post_data = b2n_find_post(blog_dir = blog_dir,
                            post = post)
  html_msg = gmailr::gm_mime() |>
    gmailr::gm_html_body(post_data$item_description)

  return(list(email = html_msg,
              post = dplyr::select(post_data, tidyselect::starts_with("item"))))
}

#' add matching subscribers
#'
#' Given a blog post email and subscriber data, finds subscribers who have matching categories,
#' and adds them to the bcc field of the email, if any exist.
#'
#' @param post_email a blog post email created by `b2n_post_to_email`
#' @param subscriber_data subscriber data from `b2n_fetch_subscribers`
#'
#' @export
#' @return list
b2n_add_subscribers = function(post_email, subscriber_data = NULL)
{
  if (is.null(subscriber_data)) {
    stop(cli::format_error(c("{.arg subscriber_data} is missing or NULL!",
                             "x" = "You didn't provide {.arg subscriber_data}",
                             "i" = "Load {.arg subscriber_data} using {.var b2n_fetch_subscribers()} first.")))
  }
  post_subscribers = b2n_match_subscribers_categories(unlist(post_email$post$item_category), subscriber_data)

  if (length(post_subscribers) == 0) {
    base::message(cli::format_message(c("x" = "No subscribers matching the post categories!",
                                        "i" = "No email to compose.")))
    return(invisible())
  }
  post_email$email = post_email$email |>
    gmailr::gm_bcc(post_subscribers)
  return(post_email)
}

#' add from address
#'
#' Adds a `from` email address to the `post_email`.
#'
#' @param post_email generated by `b2n_post_to_email`
#' @param from_email the email address to use
#'
#' @export
#' @return list
b2n_from = function(post_email, from_email = NULL)
{
  if (is.null(from_email)) {
    stop(cli::format_error(c("{.arg from_email} is missing or NULL!",
                             "x" = "You didn't provide {.arg from_email}",
                             "i" = "Please make sure you provide an email address!")))
  }
  post_email$email = post_email$email |>
    gmailr::gm_from(from_email)
  return(post_email)
}

#' add subject
#'
#' Adds the post title as a subject, and optionally adds extra text in front of it.
#'
#' @param post_email the post email from `b2n_post_to_email`
#' @param presubject extra text to prepend to the subject line
#'
#' @export
#' @return list
b2n_add_subject = function(post_email, presubject = "")
{
  if (nchar(presubject) > 0) {
    extra_subject = paste0(presubject, " ")
  } else {
    extra_subject = ""
  }
  post_email$email = post_email$email |>
    gmailr::gm_subject(paste0(extra_subject, post_email$post$item_title))

  return(post_email)
}

b2n_match_subscribers_categories = function(categories,
                                            subscriber_data)
{

  all_subscribers = subscriber_data |>
    dplyr::filter(category %in% "All") |>
    dplyr::pull(email)
  matched_subscribers = subscriber_data |>
    dplyr::filter(category %in% categories) |>
    dplyr::pull(email)
  c(all_subscribers, matched_subscribers)
}

#' find a post
#'
#' Return either the `latest` post, or one matching a provided title.
#'
#' @param blog_dir the location for the RSS
#' @param post which post to get
#'
#' @export
#' @return tibble
b2n_find_post = function(blog_dir,
                         post = "latest")
{
  if (fs::is_dir(blog_dir)) {
    rss_index = file.path(blog_dir, "_site", "index.xml")
    if (fs::file_exists(rss_index)) {
      rss_data = tidyRSS:::rss_parse(rss_index, list = FALSE, clean_tags = FALSE, parse_dates = TRUE) |>
        dplyr::arrange(dplyr::desc(item_pub_date))
    } else {
      stop(cli::format_error(c("No index.xml file found at {.file {rss_index}}:",
                               "x" = 'You provided {.arg blog_dir = "{blog_dir}"}',
                               "i" = "Please double check that the blog directory exists and has an RSS feed.")))
    }

  } else if (fs::is_file(blog_dir)) {
    if (fs::file_exists(blog_dir)) {
      rss_data = tidyRSS:::rss_parse(blog_dir, list = FALSE, clean_tags = FALSE, parse_dates = TRUE) |>
        dplyr::arrange(dplyr::desc(item_pub_date))
    } else {
      stop(cli::format_error(c("No file found at {.file {blog_dir}}:",
                               "x" = 'You provided {.arg blog_dir = "{blog_dir}"}',
                               "i" = "Please double check that the file exists.")))
    }
  } else if (grepl("^http", blog_dir)) {
    rss_data = tidyRSS::tidyfeed(blog_dir, list = FALSE, clean_tags = FALSE, parse_dates = TRUE) |>
      dplyr::arrange(dplyr::desc(item_pub_date))
  }

  if (post %in% "latest") {
    use_post = rss_data |>
      dplyr::slice_head(n = 1)
    cli::cli_alert_success("Using latest post titled: {use_post$item_title}.")
  } else {
    use_post = rss_data |>
      dplyr::filter(grepl(post, item_title, ignore.case = TRUE))
    if (nrow(use_post) == 0) {
      stop(cli::format_error(c("No posts found to send out:",
                               "x" = "You provided the title {.arg {post}}",
                               "i" = "Double check the spelling of the title provided in {.arg post}?")))
    } else if (nrow(use_post) > 1) {
      stop(cli::format_error(c("Multiple posts found to send out:",
                               "x" = "You provided the title {.arg {post}}",
                               "i" = "Double check the spelling of the title provided in {.arg post}?")))
    } else {
      cli::cli_alert_success("Matched supplied post title {post}: {use_post$item_title}.")
    }
  }
  return(use_post)
}

#' send it
#'
#' Send the post email!
#'
#' @param post_email email created by `b2n_post_to_email`
#' @param cache the blog2newsletter cache location
#' @param force send it even if it was previously sent
#'
#' @export
#' @seealso b2n_compose
b2n_send_newsletter = function(post_email,
                               cache = "_blog2newsletter",
                               force = FALSE)
{
  email_cache = file.path(cache, "emails")
  if (fs::dir_exists(cache)) {
    if (fs::file_exists(email_cache)) {
      old_emails = readRDS(email_cache)
    } else {
      old_emails = post_email$post[-1, ]
      old_emails$send_date = as.character(NA)
    }
  }
  new_post = post_email$post
  match_loc = which(old_emails$item_title %in% new_post$item_title)
  if (length(match_loc) == 0) {
    message(cli::cli_alert_info("Sending newsletter!"))
    gmailr::send_message(post_email$email)

    new_post$send_date = as.character(Sys.time())
    old_emails = dplyr::bind_rows(old_emails, new_post)
    saveRDS(old_emails, file = email_cache)
    return(invisible())
  } else {

    if (length(match_loc) == 1) {
      match_links = old_emails[match_loc, ]
      if (force) {
        message(cli::cli_alert_info("Forcing sending newsletter!"))
        gmailr::send_message(post_email$email)
        old_emails$send_date[match_loc] = as.character(Sys.time())
        saveRDS(old_emails, file = email_cache)
        return(invisible())
      } else {
        stop(cli::format_message(c('Found match to previously sent newsletter!',
                                   "i" = 'You previously sent "{match_links$item_title}" on {match_links$send_date}.',
                                   "i" = 'You can force resending it using {.arg force = TRUE}.')))
      }
    } else {
      stop(cli::format_message(c("Found multiple matches to previously sent newsletters.",
                                 "i" = "This shouldn't have happened, please examine the cache directly.",
                                 "i" = 'You can do this with {.var old_emails = readRDS("{cache}")}')))
    }
  }
}


#' creates draft in gmail
#'
#' Given the composed email, sends the email to GMail so it can be viewed in the *drafts* folder.
#'
#' @param post_email the post, created with `b2n_post_to_email`
#'
#' @export
#' @return NULL
b2n_draft_email = function(post_email)
{
  gmailr::gm_create_draft(post_email$email)
}
